## 实例顺序
1. 稀疏数组的转换 sparsearray
2. queue
   1. 用数组实现队列 queue
   2. 用队列实现环形队列 queue
3. linkedlist
   1. 单向链表 linkedlist
   2. 双向链表 linkedlist
   3. 环形单向链表 linkedlist
4. stack
5. 递归 recursion
   1. 走迷宫maze
   2. 8 queue
## 排序
### 内部排序：内存中排序
1. 插入排序
   1. *直接插入
   2. 希尔排序
2. 选择排序
   1. *简单选择
   2. 堆排序
3. 交换排序
   1. *冒泡
   2. 快速排序
4. 归并排序
5. 基数排序（统排？）
### 外部排序

## 哈希表
通过关键码值，根据散列函数计算映射到对应的存储位置，从而找到对应的信息；存放数据的数组叫散列表（哈希表）
散列表（哈希表）：根据关键码值直接进行访问的数据结构

## 树
1. 二叉树：每个节点最多只有2个子节点
   1. 满二叉树：叶子节点都在最后一行；元素个数为 2^n - 1
   2. 完全二叉树：叶子节点在最后或倒数第二行；左侧最后一行叶子节点连续，右侧倒数第二行叶子节点连续
2. 线索化二叉树
   1. n 个节点的二叉链表含有 n+1 个空指针（n-1条连接线）,（2n - (n-1)）= n+1;也就是说每个节点都是单线联系
   2. 该空指针指向该节点按照某种遍历次序的前驱或后继节点；这种附加指针 --> 线索
   3. 某种遍历次序：前序、中序、后序；按照此顺序，节点分为前驱或后继节点；节点同时还有左子树和右子树节点，要注意区分
3. 赫夫曼树：所有叶子节点的带权路径之和最小
   1. 赫夫曼编码：可变字长的编码VLC;压缩率20%-90%；无损处理
      1. 用赫夫曼编码压缩 文件
4. 二叉排序树 BinarySortTree：任何非叶子节点，其左子节点、当前节点、右子节点值相等或递增；查找和插入速度较快
5. 平衡二叉树(平衡二叉搜索树 Self-balancing binary search tree) AVL
   1. 任一节点的左右两个子树的高度差的绝对值不超过1；或空树
6. 多路查找树
   1. 多叉树：允许节点存储多个数据项或有多个子节点
   2. B树 Balanced：重新组织节点，降低高度，提升效率；
      1. 特点：所有叶子节点都在同一层
         1. 节点的度：子节点的个数
         2. 树的度：节点的度的最大值
         3. B树的阶：最多子节点的个数
   3. 2-3树：简单的B树
      1. 由2节点或3节点组成，即要么有2个子节点，要么有3个子节点，要么没有子节点
      2. 2节点有1个数据项，3节点有2个数据项
      3. 要满足排序树的规则：左子节点，当前节点，右子节点值递增
   4. 2-3-4树：类似
   5. B+树： 所有值都在叶子节点（稠密索引）；非叶子节点为稀疏索引
   6. B*树：中间节点增加指向兄弟节点的指针；空间使用率更高
## 图
1. 分类
   1. 无向图
   2. 有向图
   3. 带权图
2. 数据结构
   1. 二维数组：邻接矩阵；对不存在的边，矩阵值为0；有空间浪费
   2. 邻接表 ： 链表 / 数组+链表； 没有空间浪费
3. 图的遍历
   1. 深度优先 depth first search(dfs)
   2. 广度优先
## 算法
1. 二分查找非递归 O(log2n)
2. 分治：子问题无关联 - 汉诺塔问题
3. 动态规划算法：子问题求解相互关联 - 背包问题： 01背包：不允许重复内容； 完全背包：背包可放重复内容，可转为01背包
4. KMP算法：字符串匹配问题
5. 贪心算法 Greedy
6. 普里姆算法 修路问题 -- 求最小生成树 min cost spanning tree MST
   1. n个顶点，n-1条边，所有边都在图中 -- 找极小连通子图
7. kruskal算法 公交站问题 -- 求最小生成树
8. 狄杰斯特拉算法
   1. 求最短路径
   2. 广度优先算法
9. floyd算法
   1. 各点之间的最短路径
10. 马踏棋盘问题